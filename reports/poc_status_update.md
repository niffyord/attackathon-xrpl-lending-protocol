# Batch PoC Status – 2025-11-07

## Latest Update — 2025-11-07 14:05 UTC
- Documented XRPL IOU precision guardrail (15 significant digits per [xrpl.org docs](https://xrpl.org/docs/concepts/tokens)) inside this runbook so we stop recreating Scale = 12 vaults for 1e18 flows. All new issuance sticks to Scale = 0/1 and scientific-notation `value` strings to stay inside the mantissa limit—no more `tecPATH_DRY` or truncated deposits.
- Brought up a *second* Scale = 0 vault (`VaultID = C4686F9351F281A0C6610E7C0A462DEF71AAD4729F731A6C33AE14DFB70D3BE2`) plus LoanBroker `657530572AF9F1DBCE7A9CC7FB760BCADC665EAB4C0908E9C328C6915F7B9CD0` dedicated to the rounding-gap exploit. Batch `EDEAE55549E3DE421DD65F049DFA76BD2BDF034BE548989E7E3EBCF4ADE3DE61` (flags `tfFullyCanonicalSig | tfIndependent`) originated a fractional principal of `1.234567890123e12` drops with borrower BatchSigner produced via `scripts/build_batch_signers.js`.
- Current ledger view (`LoanBroker` entry at `6575…9CD0`): `DebtTotal = 1234567890123000e-3`, `CoverAvailable = 100000000` after the last successful `LoanBrokerCoverWithdraw` (`hash 1BB25CAD043E01370AC448E9619467D85ACEED5983FF7CDEC5D2633B27474B94`). Smaller follow-up withdraw attempts (`20B9870590914BE5…`, `D38C955642EBDB4E…`) are getting `tecINSUFFICIENT_FUNDS`, confirming we are sitting on the rounded floor but still need true slack (>roundToAsset, <actual minimum).
- Submission history for the “manual Batch only” requirement is clean: every payload was hand-crafted JSON replayed via `curl` (no helper scripts beyond `build_batch_signers.js`). `reports/submitted/high/report-58178-loanpay-fee-routing/resubmission.md` remains accurate up through the canonical Batch flow; the only missing artifact is the final LoanPay mis-routing once slack exists.
- Replaced the old Scale = 3 vault with a Scale = 0 vault so large deposits can be expressed in scientific notation without hitting XRPL’s 15-digit mantissa cap (`VaultID = F479944BAD6222005AC428883D390481491975734DBFF75BFE49202D38F5D6DD`, `LoanBrokerID = D9A02C46753F87BD3F946B159AFC6BA81DD25F04E5A6379478DC44A4216C5173`).
- Refunded the broker trust line (limit `1e24`) and vault using `"1e18"`/`"1.0000000000002e18"` so `DebtTotal` and `CoverAvailable` land at the intended magnitudes without `tecPATH_DRY`.
- Rebuilt the canonical Batch (inner `LoanSet` + filler `Payment`) with borrower BatchSigner generated via `scripts/build_batch_signers.js`. Latest Batch hash `5E1AD5BA05112787B575D9483809AB9C7594C69AB15C104C0BCA3AF4D8D7EF9B` produced Loan `7332E52B6252F597CB76B988416CCDC0260C7111EF733204BE70DD50C946A008`.
- Executed the borrower’s first scheduled payment (`LoanPay` hash `04A60E334B0F3411DFD24A8870ACE841CC4A4A55F9A1740807227710F3094932`), which lowered `DebtTotal` to `9.166666666666670e17` while keeping `LoanScale = 3`.
- Walked cover down with two large withdrawals (`C395E1C24C3B8ED6698AE80E79E7B19C65B6796A9B8E60E05465B9EA7C5233C4`, `8A73CA490A759DAF613E0218ED52F4BEB4A93CAE0E59B01C1FCE0C9B843A04D9`) to arrive at `CoverAvailable = 9,166,666,666,666.67`. A further 500-unit attempt (`E9E2734DF912FCB45BF257EA93CAF45F2DC5BA160F43FADBB48E3DB0DEF6FC5E`, `tecINSUFFICIENT_FUNDS`) shows we are exactly on the analytic minimum—rounding slack still zero because `roundToAsset` matches the true requirement with the current debt granularity.
- Found a working rounding gap on the high-principal broker: withdraw `0BEF504456D4087066739DB0E1EBE0810A3D66A6123225B7FDBF7A4C9692D941` set `sfCoverAvailable = 9,166,666,666,640` while the true minimum cover was `9,166,666,666,666.793` (gap `≈26.8`). `LoanPay` hash `49E18396D6F6464AAC76D11167679B34462C6F2F8CEF0277E2B5C9D8995E1EFA` succeeded in that state with `sfCoverAvailable` unchanged, proving the predicate only looked at the rounded floor. Repeated the maneuver at the next payment window (hash `D76CE6BD96DF51CCBBCD4FC6069E558789D06C47F434B8995C4EBDB31198F710`) to record deterministic JSON snapshots (`loanbroker_before.json`/`loanbroker_after.json`) for the report.
- Provisioned a third broker strictly for the fee-routing proof: Vault `A034E2E871F3E94355EACD697A5404177DA0426665407C26E37ED1575F33BA16`, LoanBroker `5892AEB9376F42CDE019265A1A2E895DF8FA56549AE4FB128A5C5EF64A89132A` with `sfManagementFeeRate = 100` and cover `1.0000000000002e18`. Batch `7464D4B6CF3332ADC402E3A5358B069C98D9FB1899E477A29979788D092096CF` created the service-fee loan (`LoanID F9EE810F8A31BDC6E34B016F3B54949E7AB86D889FC56F4D428439C5AD2F0FAB`, `LoanServiceFee = 1e12`). Initial `LoanPay` hash `4711E9B435A03A5485B12BEE9CCC06BDA37EC906B13638BD920F61B16B3B61B1` confirmed debt drops without touching cover.
- Ongoing: walking this broker’s cover into the `[roundToAsset, true minimum)` window. Large withdraw `E5945975829BD71476F949EFD22DA0DD757286895DBFBF1B9FA7B991AF96E1EA` and the follow-up `2FF12E0572503F6E055E4CE2FE0202957D7122FD14CC997C03ABDDE9960C08F2` brought cover down to `9.166666661e12`; the next bulk withdraw (`10FC28065A9AA366…`) failed because it dipped below the enforceable minimum. We’re recalculating the precise limit before issuing the final withdraw(s) needed to capture the fee mis-routing with a nonzero service fee.

## Issues Already Solved
- **temBAD_SIGNATURE** — borrower signature now comes from `scripts/build_batch_signers.js`, so it matches the canonical `{flags, txIDs}` digest and verifies with `tfFullyCanonicalSig | tfIndependent`.
- **Sequence drift** — templates default to `Sequence = n` outer / `n+1`, `n+2` inner so `checkSeqProxy` always sees contiguous values.
- **temARRAY_EMPTY / temINVALID_INNER_BATCH** — filler Payment (1 drop, `tfInnerBatchTxn`) keeps `RawTransactions ≥ 2` and avoids zero-amount self-payments.
- **IOU precision** — Scale = 0 vault + scientific-notation strings keep all big deposits/originations under the 15-digit mantissa limit, eliminating `tecPATH_DRY`.
- **Workspace hygiene** — only the live JSON helpers (batch configs, wallet exports, borrower signature cache) remain so replays stay deterministic.

## Guardrails / Lessons
- Inner transactions must remain byte-identical after the borrower signs; any tweak to `Account`, `Fee`, `Sequence`, `Flags`, or decimal formatting requires regenerating the BatchSigner signature.
- Keep using scientific notation for any IOU ≥ 10¹³ so XRPL mantissa limits aren’t exceeded.
- Outer Batch sequence `n` implies inner sequences `n+1`, `n+2`, …; violating that ordering reintroduces `tefPAST_SEQ`.
- Batch submissions always need ≥2 inners (LoanSet + filler Payment), all tagged with `tfInnerBatchTxn`, zero fee, and empty `SigningPubKey`.

- `DebtTotal` exponent (−3) + Scale = 0 asset means `roundToAsset` still matches the analytic minimum. Need either (1) a higher-scale vault/loan so minimum cover lands between integer steps, or (2) additional micro-loans that introduce non-`10^3` divisibility before the exploit steps.
- LoanPay mis-routing remains unproven until cover can be held strictly between `roundToAsset` and the true required cover (the “rounding gap”).
- We now have a LoanBroker with `sfManagementFeeRate = 100` and a dedicated loan (`LoanID F9EE…FAB`), but the cover-withdrawal logic (`LoanBrokerCoverWithdraw`) enforces its own `minimumCover` ceiling, so large withdraws fail before we reach the slack. Need to compute the exact allowable floor (`roundToAsset(tenthBipsOfValue(sfDebtTotal), debt.exponent())`) so we can land in the gap without tripping `tecINSUFFICIENT_FUNDS`.

## Next Steps
1. Use the mgmt-fee broker (`5892…9132A`) to finish walking cover into the gap (alternate successful/failed `LoanBrokerCoverWithdraw` calls until `sfCoverAvailable` is between the rounded floor and true minimum).
2. Run `LoanPay` again with cover in that gap, capture broker trustlines + `LoanBroker` diffs showing the fee credited to `rBrR…` while cover remains below the real requirement.
3. Archive hashes/JSON (new Batch, withdraws, LoanPay) and update `reports/submitted/high/report-58178-loanpay-fee-routing/resubmission.md` with the final evidence.
